\hypertarget{class_heap_block}{}\doxysection{Heap\+Block\texorpdfstring{$<$}{<} Element\+Type, throw\+On\+Failure \texorpdfstring{$>$}{>} Class Template Reference}
\label{class_heap_block}\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}


{\ttfamily \#include $<$juce\+\_\+\+Heap\+Block.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{class_heap_block_a307b1d80d74bd7b39c8b3b70a8a681b1}{Type}} = Element\+Type
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_heap_block_a720865797ff4f5e9e92432b0b231d110}{Heap\+Block}} ()=default
\item 
{\footnotesize template$<$typename Size\+Type , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ Size\+Type, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$\+::value, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$  = 0$>$ }\\\mbox{\hyperlink{class_heap_block_a7b5c4b5a56551744a36f68eefc27f6d7}{Heap\+Block}} (Size\+Type num\+Elements)
\item 
{\footnotesize template$<$typename Size\+Type , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ Size\+Type, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$\+::value, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$  = 0$>$ }\\\mbox{\hyperlink{class_heap_block_a6fa48a9a24fa7b9b84967c1c6aa29e24}{Heap\+Block}} (Size\+Type num\+Elements, bool initialise\+To\+Zero)
\item 
\mbox{\hyperlink{class_heap_block_abf392fafab8530d45132eaeb81ff372d}{$\sim$\+Heap\+Block}} ()
\item 
\mbox{\hyperlink{class_heap_block_a43e44081c3cbef5f634dd5a2a58cd1bd}{Heap\+Block}} (\mbox{\hyperlink{class_heap_block}{Heap\+Block}} \&\&other) noexcept
\item 
\mbox{\hyperlink{class_heap_block}{Heap\+Block}} \& \mbox{\hyperlink{class_heap_block_a059eccbbcdec115b958b98e885e73f87}{operator=}} (\mbox{\hyperlink{class_heap_block}{Heap\+Block}} \&\&other) noexcept
\item 
{\footnotesize template$<$class Other\+Element\+Type , bool other\+Throw\+On\+Failure, typename  = Allow\+Conversion$<$\+Other\+Element\+Type$>$$>$ }\\\mbox{\hyperlink{class_heap_block_a43360d0b67112a64db4c131cfe976a31}{Heap\+Block}} (\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Other\+Element\+Type, other\+Throw\+On\+Failure $>$ \&\&other) noexcept
\item 
{\footnotesize template$<$class Other\+Element\+Type , bool other\+Throw\+On\+Failure, typename  = Allow\+Conversion$<$\+Other\+Element\+Type$>$$>$ }\\\mbox{\hyperlink{class_heap_block}{Heap\+Block}} \& \mbox{\hyperlink{class_heap_block_abd3c3fe2912d1b8f4922f64419aae367}{operator=}} (\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Other\+Element\+Type, other\+Throw\+On\+Failure $>$ \&\&other) noexcept
\item 
\mbox{\hyperlink{class_heap_block_af6d00012477feaaab90bcf100d05d08a}{operator Element\+Type $\ast$}} () \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block_ad336734ceae0e07276c425124ffa8f65}{get}} () \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block_a8e954123636b2c26e907ed6d83fd837d}{get\+Data}} () \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
\mbox{\hyperlink{class_heap_block_a912268a681322c1234753bd580bf1f89}{operator void $\ast$}} () \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
\mbox{\hyperlink{class_heap_block_af51c07aad68df37e185d1f452a5ace97}{operator const void $\ast$}} () \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block_aad12ca2ecec289f02804ebadf66c8824}{operator-\/$>$}} () \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
{\footnotesize template$<$typename Index\+Type $>$ }\\Element\+Type \& \mbox{\hyperlink{class_heap_block_a00c4845c176be4b09b8ac8ea564c2675}{operator\mbox{[}$\,$\mbox{]}}} (Index\+Type index) \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
{\footnotesize template$<$typename Index\+Type $>$ }\\Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block_a3a40c7fb209f5734da99104110489716}{operator+}} (Index\+Type index) \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
bool \mbox{\hyperlink{class_heap_block_a62b93f40a1a4fd2e7d5fab4b175ae7b8}{operator==}} (\mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} Element\+Type $\ast$other\+Pointer) \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
bool \mbox{\hyperlink{class_heap_block_a881616c651ba81789a1a4455b3f327a2}{operator!=}} (\mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} Element\+Type $\ast$other\+Pointer) \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} noexcept
\item 
{\footnotesize template$<$typename Size\+Type $>$ }\\\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}{malloc}} (Size\+Type new\+Num\+Elements, size\+\_\+t element\+Size=sizeof(Element\+Type))
\item 
{\footnotesize template$<$typename Size\+Type $>$ }\\\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block_ae85c772e650f78ec449611e4a5dea301}{calloc}} (Size\+Type new\+Num\+Elements, \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} size\+\_\+t element\+Size=sizeof(Element\+Type))
\item 
{\footnotesize template$<$typename Size\+Type $>$ }\\\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block_a270cb60aeab3ed372e901d64cdc9b9ab}{allocate}} (Size\+Type new\+Num\+Elements, bool initialise\+To\+Zero)
\item 
{\footnotesize template$<$typename Size\+Type $>$ }\\\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block_a74f9707f0bf150324c9b490bd8979b3e}{realloc}} (Size\+Type new\+Num\+Elements, size\+\_\+t element\+Size=sizeof(Element\+Type))
\item 
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free}} () noexcept
\item 
{\footnotesize template$<$bool other\+Block\+Throws$>$ }\\\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block_a7ebc384a5d3f8ccfb56229688a0a273c}{swap\+With}} (\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, other\+Block\+Throws $>$ \&other) noexcept
\item 
{\footnotesize template$<$typename Size\+Type $>$ }\\\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block_ac3022f7ea29a9292ec53239a1ac66090}{clear}} (Size\+Type num\+Elements) noexcept
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Other\+Element\+Type , bool other\+Throw\+On\+Failure$>$ }\\class \mbox{\hyperlink{class_heap_block_a8f9f6aa2b0f01a6891b2031ce2eb77fc}{Heap\+Block}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class Element\+Type, bool throw\+On\+Failure = false$>$\newline
class Heap\+Block$<$ Element\+Type, throw\+On\+Failure $>$}
Very simple container class to hold a pointer to some data on the heap.

When you need to allocate some heap storage for something, always try to use this class instead of allocating the memory directly using malloc/free.

A Heap\+Block$<$char$>$ object can be treated in pretty much exactly the same way as an char$\ast$, but as long as you allocate it on the stack or as a class member, it\textquotesingle{}s almost impossible for it to leak memory.

It also makes your code much more concise and readable than doing the same thing using direct allocations,

E.\+g. instead of this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}* temp = (\textcolor{keywordtype}{int}*) \mbox{\hyperlink{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}{malloc}} (1024 * \textcolor{keyword}{sizeof} (\textcolor{keywordtype}{int}));}
\DoxyCodeLine{memcpy (temp, xyz, 1024 * \textcolor{keyword}{sizeof} (\textcolor{keywordtype}{int}));}
\DoxyCodeLine{\mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free}} (temp);}
\DoxyCodeLine{temp = (\textcolor{keywordtype}{int}*) \mbox{\hyperlink{class_heap_block_ae85c772e650f78ec449611e4a5dea301}{calloc}} (2048 * \textcolor{keyword}{sizeof} (\textcolor{keywordtype}{int}));}
\DoxyCodeLine{temp[0] = 1234;}
\DoxyCodeLine{memcpy (foobar, temp, 2048 * \textcolor{keyword}{sizeof} (\textcolor{keywordtype}{int}));}
\DoxyCodeLine{\mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free}} (temp);}

\end{DoxyCode}


..you could just write this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_heap_block}{HeapBlock<int>}} temp (1024);}
\DoxyCodeLine{memcpy (temp, xyz, 1024 * \textcolor{keyword}{sizeof} (\textcolor{keywordtype}{int}));}
\DoxyCodeLine{temp.calloc (2048);}
\DoxyCodeLine{temp[0] = 1234;}
\DoxyCodeLine{memcpy (foobar, temp, 2048 * \textcolor{keyword}{sizeof} (\textcolor{keywordtype}{int}));}

\end{DoxyCode}


The class is extremely lightweight, containing only a pointer to the data, and exposes malloc/realloc/calloc/free methods that do the same jobs as their less object-\/oriented counterparts. Despite adding safety, you probably won\textquotesingle{}t sacrifice any performance by using this in place of normal pointers.

The throw\+On\+Failure template parameter can be set to true if you\textquotesingle{}d like the class to throw a std\+::bad\+\_\+alloc exception when an allocation fails. If this is false, then a failed allocation will just leave the heapblock with a null pointer (assuming that the system\textquotesingle{}s \mbox{\hyperlink{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}{malloc()}} function doesn\textquotesingle{}t throw).

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_array}{Array}}, \mbox{\hyperlink{class_owned_array}{Owned\+Array}}, \mbox{\hyperlink{class_memory_block}{Memory\+Block}}
\end{DoxySeeAlso}
@tags\{Core\} 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_heap_block_a307b1d80d74bd7b39c8b3b70a8a681b1}\label{class_heap_block_a307b1d80d74bd7b39c8b3b70a8a681b1}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!Type@{Type}}
\index{Type@{Type}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{Type}{Type}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
using \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::\mbox{\hyperlink{class_heap_block_a307b1d80d74bd7b39c8b3b70a8a681b1}{Type}} =  Element\+Type}

This typedef can be used to get the type of the heapblock\textquotesingle{}s elements. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_heap_block_a720865797ff4f5e9e92432b0b231d110}\label{class_heap_block_a720865797ff4f5e9e92432b0b231d110}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!HeapBlock@{HeapBlock}}
\index{HeapBlock@{HeapBlock}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{HeapBlock()}{HeapBlock()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::\mbox{\hyperlink{class_heap_block}{Heap\+Block}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}

Creates a \mbox{\hyperlink{class_heap_block}{Heap\+Block}} which is initially just a null pointer.

After creation, you can resize the array using the \mbox{\hyperlink{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}{malloc()}}, \mbox{\hyperlink{class_heap_block_ae85c772e650f78ec449611e4a5dea301}{calloc()}}, or \mbox{\hyperlink{class_heap_block_a74f9707f0bf150324c9b490bd8979b3e}{realloc()}} methods. \mbox{\Hypertarget{class_heap_block_a7b5c4b5a56551744a36f68eefc27f6d7}\label{class_heap_block_a7b5c4b5a56551744a36f68eefc27f6d7}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!HeapBlock@{HeapBlock}}
\index{HeapBlock@{HeapBlock}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{HeapBlock()}{HeapBlock()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Size\+Type , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ Size\+Type, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$\+::value, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$  = 0$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::\mbox{\hyperlink{class_heap_block}{Heap\+Block}} (\begin{DoxyParamCaption}\item[{Size\+Type}]{num\+Elements }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

Creates a \mbox{\hyperlink{class_heap_block}{Heap\+Block}} containing a number of elements.

The contents of the block are undefined, as it will have been created by a malloc call.

If you want an array of zero values, you can use the \mbox{\hyperlink{class_heap_block_ae85c772e650f78ec449611e4a5dea301}{calloc()}} method or the other constructor that takes an Initialisation\+State parameter. \mbox{\Hypertarget{class_heap_block_a6fa48a9a24fa7b9b84967c1c6aa29e24}\label{class_heap_block_a6fa48a9a24fa7b9b84967c1c6aa29e24}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!HeapBlock@{HeapBlock}}
\index{HeapBlock@{HeapBlock}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{HeapBlock()}{HeapBlock()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Size\+Type , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ Size\+Type, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$\+::value, \mbox{\hyperlink{group__juce__audio__plugin__client-_unity_ga966b05a42d98c7296097e073c627dcd0}{int}} $>$  = 0$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::\mbox{\hyperlink{class_heap_block}{Heap\+Block}} (\begin{DoxyParamCaption}\item[{Size\+Type}]{num\+Elements,  }\item[{bool}]{initialise\+To\+Zero }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Creates a \mbox{\hyperlink{class_heap_block}{Heap\+Block}} containing a number of elements.

The initialise\+To\+Zero parameter determines whether the new memory should be cleared, or left uninitialised. \mbox{\Hypertarget{class_heap_block_abf392fafab8530d45132eaeb81ff372d}\label{class_heap_block_abf392fafab8530d45132eaeb81ff372d}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!````~HeapBlock@{$\sim$HeapBlock}}
\index{````~HeapBlock@{$\sim$HeapBlock}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$HeapBlock()}{~HeapBlock()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::$\sim$\mbox{\hyperlink{class_heap_block}{Heap\+Block}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Destructor. This will free the data, if any has been allocated. \mbox{\Hypertarget{class_heap_block_a43e44081c3cbef5f634dd5a2a58cd1bd}\label{class_heap_block_a43e44081c3cbef5f634dd5a2a58cd1bd}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!HeapBlock@{HeapBlock}}
\index{HeapBlock@{HeapBlock}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{HeapBlock()}{HeapBlock()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::\mbox{\hyperlink{class_heap_block}{Heap\+Block}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Move constructor \mbox{\Hypertarget{class_heap_block_a43360d0b67112a64db4c131cfe976a31}\label{class_heap_block_a43360d0b67112a64db4c131cfe976a31}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!HeapBlock@{HeapBlock}}
\index{HeapBlock@{HeapBlock}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{HeapBlock()}{HeapBlock()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$class Other\+Element\+Type , bool other\+Throw\+On\+Failure, typename  = Allow\+Conversion$<$\+Other\+Element\+Type$>$$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::\mbox{\hyperlink{class_heap_block}{Heap\+Block}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Other\+Element\+Type, other\+Throw\+On\+Failure $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Converting move constructor. Only enabled if this is a Heap\+Block$<$\+Base$\ast$$>$ and the other object is a Heap\+Block$<$\+Derived$\ast$$>$, where std\+::is\+\_\+base\+\_\+of$<$\+Base, Derived$>$\+::value == true. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_heap_block_a270cb60aeab3ed372e901d64cdc9b9ab}\label{class_heap_block_a270cb60aeab3ed372e901d64cdc9b9ab}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!allocate@{allocate}}
\index{allocate@{allocate}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Size\+Type $>$ \\
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::allocate (\begin{DoxyParamCaption}\item[{Size\+Type}]{new\+Num\+Elements,  }\item[{bool}]{initialise\+To\+Zero }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Allocates a specified amount of memory and optionally clears it. This does the same job as either \mbox{\hyperlink{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}{malloc()}} or \mbox{\hyperlink{class_heap_block_ae85c772e650f78ec449611e4a5dea301}{calloc()}}, depending on the initialise\+To\+Zero parameter. \mbox{\Hypertarget{class_heap_block_ae85c772e650f78ec449611e4a5dea301}\label{class_heap_block_ae85c772e650f78ec449611e4a5dea301}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!calloc@{calloc}}
\index{calloc@{calloc}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{calloc()}{calloc()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Size\+Type $>$ \\
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::calloc (\begin{DoxyParamCaption}\item[{Size\+Type}]{new\+Num\+Elements,  }\item[{\mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} size\+\_\+t}]{element\+Size = {\ttfamily sizeof~(ElementType)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Allocates a specified amount of memory and clears it. This does the same job as the \mbox{\hyperlink{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}{malloc()}} method, but clears the memory that it allocates. \mbox{\Hypertarget{class_heap_block_ac3022f7ea29a9292ec53239a1ac66090}\label{class_heap_block_ac3022f7ea29a9292ec53239a1ac66090}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!clear@{clear}}
\index{clear@{clear}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Size\+Type $>$ \\
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::clear (\begin{DoxyParamCaption}\item[{Size\+Type}]{num\+Elements }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

This fills the block with zeros, up to the number of elements specified. Since the block has no way of knowing its own size, you must make sure that the number of elements you specify doesn\textquotesingle{}t exceed the allocated size. \mbox{\Hypertarget{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}\label{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!free@{free}}
\index{free@{free}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{free()}{free()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::free (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Frees any currently-\/allocated data. This will free the data and reset this object to be a null pointer. \mbox{\Hypertarget{class_heap_block_ad336734ceae0e07276c425124ffa8f65}\label{class_heap_block_ad336734ceae0e07276c425124ffa8f65}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!get@{get}}
\index{get@{get}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::get (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns a raw pointer to the allocated data. This may be a null pointer if the data hasn\textquotesingle{}t yet been allocated, or if it has been freed by calling the \mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free()}} method. \mbox{\Hypertarget{class_heap_block_a8e954123636b2c26e907ed6d83fd837d}\label{class_heap_block_a8e954123636b2c26e907ed6d83fd837d}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!getData@{getData}}
\index{getData@{getData}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{getData()}{getData()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::get\+Data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns a raw pointer to the allocated data. This may be a null pointer if the data hasn\textquotesingle{}t yet been allocated, or if it has been freed by calling the \mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free()}} method. \mbox{\Hypertarget{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}\label{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!malloc@{malloc}}
\index{malloc@{malloc}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{malloc()}{malloc()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Size\+Type $>$ \\
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::malloc (\begin{DoxyParamCaption}\item[{Size\+Type}]{new\+Num\+Elements,  }\item[{size\+\_\+t}]{element\+Size = {\ttfamily sizeof~(ElementType)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Allocates a specified amount of memory.

This uses the normal malloc to allocate an amount of memory for this object. Any previously allocated memory will be freed by this method.

The number of bytes allocated will be (new\+Num\+Elements $\ast$ element\+Size). Normally you wouldn\textquotesingle{}t need to specify the second parameter, but it can be handy if you need to allocate a size in bytes rather than in terms of the number of elements.

The data that is allocated will be freed when this object is deleted, or when you call \mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free()}} or any of the allocation methods. \mbox{\Hypertarget{class_heap_block_af51c07aad68df37e185d1f452a5ace97}\label{class_heap_block_af51c07aad68df37e185d1f452a5ace97}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator const void $\ast$@{operator const void $\ast$}}
\index{operator const void $\ast$@{operator const void $\ast$}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator const void $\ast$()}{operator const void *()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator \mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} \mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} $\ast$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns a void pointer to the allocated data. This may be a null pointer if the data hasn\textquotesingle{}t yet been allocated, or if it has been freed by calling the \mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free()}} method. \mbox{\Hypertarget{class_heap_block_af6d00012477feaaab90bcf100d05d08a}\label{class_heap_block_af6d00012477feaaab90bcf100d05d08a}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator ElementType $\ast$@{operator ElementType $\ast$}}
\index{operator ElementType $\ast$@{operator ElementType $\ast$}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator ElementType $\ast$()}{operator ElementType *()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator Element\+Type $\ast$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns a raw pointer to the allocated data. This may be a null pointer if the data hasn\textquotesingle{}t yet been allocated, or if it has been freed by calling the \mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free()}} method. \mbox{\Hypertarget{class_heap_block_a912268a681322c1234753bd580bf1f89}\label{class_heap_block_a912268a681322c1234753bd580bf1f89}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator void $\ast$@{operator void $\ast$}}
\index{operator void $\ast$@{operator void $\ast$}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator void $\ast$()}{operator void *()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator \mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} $\ast$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns a void pointer to the allocated data. This may be a null pointer if the data hasn\textquotesingle{}t yet been allocated, or if it has been freed by calling the \mbox{\hyperlink{class_heap_block_a8ec3fb69997d6f530d60cb5e0969f97f}{free()}} method. \mbox{\Hypertarget{class_heap_block_a881616c651ba81789a1a4455b3f327a2}\label{class_heap_block_a881616c651ba81789a1a4455b3f327a2}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
bool \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator!= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} Element\+Type $\ast$}]{other\+Pointer }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Compares the pointer with another pointer. This can be handy for checking whether this is a null pointer. \mbox{\Hypertarget{class_heap_block_a3a40c7fb209f5734da99104110489716}\label{class_heap_block_a3a40c7fb209f5734da99104110489716}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator+@{operator+}}
\index{operator+@{operator+}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Index\+Type $>$ \\
Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator+ (\begin{DoxyParamCaption}\item[{Index\+Type}]{index }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns a pointer to a data element at an offset from the start of the array. This is the same as doing pointer arithmetic on the raw pointer itself. \mbox{\Hypertarget{class_heap_block_aad12ca2ecec289f02804ebadf66c8824}\label{class_heap_block_aad12ca2ecec289f02804ebadf66c8824}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator-\/$>$()}{operator->()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
Element\+Type $\ast$ \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator-\/$>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Lets you use indirect calls to the first element in the array. Obviously this will cause problems if the array hasn\textquotesingle{}t been initialised, because it\textquotesingle{}ll be referencing a null pointer. \mbox{\Hypertarget{class_heap_block_a059eccbbcdec115b958b98e885e73f87}\label{class_heap_block_a059eccbbcdec115b958b98e885e73f87}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator=@{operator=}}
\index{operator=@{operator=}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}} \& \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Move assignment operator \mbox{\Hypertarget{class_heap_block_abd3c3fe2912d1b8f4922f64419aae367}\label{class_heap_block_abd3c3fe2912d1b8f4922f64419aae367}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator=@{operator=}}
\index{operator=@{operator=}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$class Other\+Element\+Type , bool other\+Throw\+On\+Failure, typename  = Allow\+Conversion$<$\+Other\+Element\+Type$>$$>$ \\
\mbox{\hyperlink{class_heap_block}{Heap\+Block}} \& \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Other\+Element\+Type, other\+Throw\+On\+Failure $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Converting move assignment operator. Only enabled if this is a Heap\+Block$<$\+Base$\ast$$>$ and the other object is a Heap\+Block$<$\+Derived$\ast$$>$, where std\+::is\+\_\+base\+\_\+of$<$\+Base, Derived$>$\+::value == true. \mbox{\Hypertarget{class_heap_block_a62b93f40a1a4fd2e7d5fab4b175ae7b8}\label{class_heap_block_a62b93f40a1a4fd2e7d5fab4b175ae7b8}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator==@{operator==}}
\index{operator==@{operator==}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
bool \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator== (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{zconf_8in_8h_a2c212835823e3c54a8ab6d95c652660e}{const}} Element\+Type $\ast$}]{other\+Pointer }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Compares the pointer with another pointer. This can be handy for checking whether this is a null pointer. \mbox{\Hypertarget{class_heap_block_a00c4845c176be4b09b8ac8ea564c2675}\label{class_heap_block_a00c4845c176be4b09b8ac8ea564c2675}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Index\+Type $>$ \\
Element\+Type \& \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{Index\+Type}]{index }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns a reference to one of the data elements. Obviously there\textquotesingle{}s no bounds-\/checking here, as this object is just a dumb pointer and has no idea of the size it currently has allocated. \mbox{\Hypertarget{class_heap_block_a74f9707f0bf150324c9b490bd8979b3e}\label{class_heap_block_a74f9707f0bf150324c9b490bd8979b3e}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!realloc@{realloc}}
\index{realloc@{realloc}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{realloc()}{realloc()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$typename Size\+Type $>$ \\
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::realloc (\begin{DoxyParamCaption}\item[{Size\+Type}]{new\+Num\+Elements,  }\item[{size\+\_\+t}]{element\+Size = {\ttfamily sizeof~(ElementType)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Re-\/allocates a specified amount of memory.

The semantics of this method are the same as \mbox{\hyperlink{class_heap_block_a29b2353f2433660bbb98066bbe3cf059}{malloc()}} and \mbox{\hyperlink{class_heap_block_ae85c772e650f78ec449611e4a5dea301}{calloc()}}, but it uses \mbox{\hyperlink{class_heap_block_a74f9707f0bf150324c9b490bd8979b3e}{realloc()}} to keep as much of the existing data as possible. \mbox{\Hypertarget{class_heap_block_a7ebc384a5d3f8ccfb56229688a0a273c}\label{class_heap_block_a7ebc384a5d3f8ccfb56229688a0a273c}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!swapWith@{swapWith}}
\index{swapWith@{swapWith}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{swapWith()}{swapWith()}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$bool other\+Block\+Throws$>$ \\
\mbox{\hyperlink{png_8h_aa8c59027f9ab2769342f248709d68d17}{void}} \mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, throw\+On\+Failure $>$\+::swap\+With (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_heap_block}{Heap\+Block}}$<$ Element\+Type, other\+Block\+Throws $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Swaps this object\textquotesingle{}s data with the data of another \mbox{\hyperlink{class_heap_block}{Heap\+Block}}. The two objects simply exchange their data pointers. 

\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{class_heap_block_a8f9f6aa2b0f01a6891b2031ce2eb77fc}\label{class_heap_block_a8f9f6aa2b0f01a6891b2031ce2eb77fc}} 
\index{HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}!HeapBlock@{HeapBlock}}
\index{HeapBlock@{HeapBlock}!HeapBlock$<$ ElementType, throwOnFailure $>$@{HeapBlock$<$ ElementType, throwOnFailure $>$}}
\doxysubsubsection{\texorpdfstring{HeapBlock}{HeapBlock}}
{\footnotesize\ttfamily template$<$class Element\+Type , bool throw\+On\+Failure = false$>$ \\
template$<$class Other\+Element\+Type , bool other\+Throw\+On\+Failure$>$ \\
friend class \mbox{\hyperlink{class_heap_block}{Heap\+Block}}\hspace{0.3cm}{\ttfamily [friend]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
build/juce\+\_\+core/memory/\mbox{\hyperlink{juce___heap_block_8h}{juce\+\_\+\+Heap\+Block.\+h}}\end{DoxyCompactItemize}
